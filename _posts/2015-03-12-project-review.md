---
layout: post
title: 北大面试准备
category: technology
---

###项目一（u-boot编译下板及内核加载）

pandaboard下板你都做了些什么，学会了什么东西？

参考答案：

主要参考我之前写过的两篇文章[文章一][1]、[文章二][2]

都做了些什么：

 - 对sd卡进行分区并写文件系统（用到了fdisk）
 - 下载u-boot源码，修改配置文件，下载交叉编译器，对其进行交叉编译
 - 将生成的u-boot镜像拷贝到sd卡中
 - 安装超级终端kermit，修改配置文件（如通信串口，速率等信息）
 - 下载内核以及所需要的工具链，采用对应的配置文件编译，编译好后将镜像拷贝至sd卡中
 - 编写引导文件使内核自动引导（将内核加载到内存）

学会了哪些东西？

- 知道了u-boot的基本工作流程：

	1. 首先，固化在ROM上的code初始化相应的外设，确定启动模式，读取下一阶段启动文件，即 SPL 文件（下文中的MLO，即ROM loads x-load），SPL（Second Program Loader) 由 ROM Code 加载到片上 SRAM 中。
	2. 其次，SPL负责完成最小系统，包括 ARM core，时钟系统，DDR，外设/存储设备等的初始化，在 DDR 中加载并运行 U-Boot 文件
	3. 然后，U-Boot 会在 SPL 系统配置的基础上，进一步配置包括网口，USB，Nand Flash 等外设或存储设备，之后会有3s的等待时间，若没有用户打断行为，则执行bootcmd脚本（注：定义在U-boot/include/configs/ti_omap4_common.h)，根据脚本依次查询boot.scr, uEnv.txt等文件（注：详细的自己看脚本去，可在文件中写code来load kernel），存在的话则执行文件中内容，否则跳到uboot shell界面。

- 了解elf格式

	ELF(Executable and Linkable Format)即可执行连接文件格式。头文件可以重定位地址。
	知道将内核加载到内存的哪个地址也是也是可以自己指定的，只要不与被占用的地址冲突。

- 用gdb进行远程调试（对arm开发板上的程序进行调试）

	首先采用交叉编译器进行编译

		$ qemu-system-arm -M kzm -S -s -nographic -kernel images/sel4test-driver-image-arm-imx31

	然后运行用来调试arm结构的gdb

		$ ./arm-none-eabi-gdb

	读取内核镜像

		(gdb) file ~/HD-Elastos/goose/images/sel4test-driver-image-arm-imx31

	连接目标开发板ip及端口

		(gdb) target remote :1234

- 知道模拟器（simulation)与仿真器(emulation)与虚拟机区别

	simulation是模拟出原系统的一个抽象模型，而不需要真的去做真实系统要做的事情。 emulation则更进一步，要真正地去做所有真实系统能做的事情，只不过做的“过程”不同，通常是为了模拟不同指令集、不同体系架构的 CPU，所以多数情况要对微指令进行解释执行。

	虚拟机，或者说虚拟化技术 virtualization，基本都是去模拟一套相同指令集相同架构的硬件平台，因此在做好保护的前提下，很多时候可以直接利用 CPU 去执行目标指令。虽然还是模拟物理 CPU 而不借助于 Host OS 的功能，毕竟少了一层指令集转换，运行速度会提高不少。

- 知道编译的时候可以自己写链接脚本指定代码段的地址以及数据段的地址

- 微内核与宏内核区别

	宏内核结构在硬件之上，定义了一个高阶的抽象界面，应用一组原语（或者叫系统调用（System call））来实现操作系统的功能，例如进程管理，文件系统，和存储管理等等，这些功能由多个运行在核心态的模块来完成。

	微内核考虑在操作系统的内核中保留操作系统最基本的功能，也就是任务调度、内存和设备的抽象和管理。其他的功能全部从内核移出，放到用户态中了实现，并以C/S模式对其他应用程序提供服务。

 用到了哪些工具：fdisk工具（分区、格式化等），编译所需的工具链

 解决了什么问题：编写操作文档，帮助别人更快的下板

###项目二（DreamWhere网站开发）

- 完成的功能

   	1. 注册登录  
   	- 设定旅游目标  
   	- 书写奋斗历程  
   	- 查看成功经历  
   	- 分享成功经历  
   	- 查看别人分享的成功经历  

- 解决了什么问题：
 
	针对年轻人空有说走就走的旅行想法却很少实施的现状，开发一个能够激发年轻人对旅游的向往并为之实践奋斗的网站显得尤为必要。
 
- 主要用到了哪些方法(人机交互的一些方法)：

	1. 编写用户引导  
	2. 尽量以图片的形式来展示  
	3. 采用尽量少的层级结构，可以快速的到达任何一个界面  
	4. 费次定律：屏幕边缘具有无限大的尺寸，按钮放边上；较小目标需要设置外边界，；有时，界面元素越小越好，比如删除按钮。  
	5. 用撤销取代对用户的干扰  
	6. 可发现性  
	7. 超链接变颜色  
	8. 提供搜索功能  
 
 > 费茨法则：是一个人机互动以及人体工程学中人类活动的模型，它预测了快速移动到目标区域所需的时间是目标区域的距离和目标区域的大小的函数。


 - 用到了什么工具：
 	
	1. 界面设计Balsamiq  [bɔl'sæmik] Mockups，是一种软件工程中快速原型的建立软件，可以做为与用户交互的一个界面草图，一旦客户认可可以做为美工开发HTML的原型使用。
	2. 数据库mysql，服务器apache，后台实现php，前台bootstrap框架，jquery库，phpmyadmin。
		
- 学到了什么东西？

	1. 小网站从前台到后台的开发建立过程及基本结构
	2. 增加动手实践能力，编程能力

###项目三（单周期mips cpu开发）

![Alt data-path][data-path]

 - 开发板：基于Spartan-6的由Digilent（德致伦）公司研发的Nexys3开发板

 - 都做了什么

	从最简单的程序计数器、数据选择器等开始学习编写，完成一个一个简单模块，然后调用小模块完成大一点的模块，比如Alu模块里面就包含了选择器、加法器、移位器等，最后把各个模块连接起来，就组成了一个简单的mips单周期cpu，进行测试下板。  
	最顶层的分为指令存储器模块、数据存储器模块、接口模块，然后Alu和指令译码器等其他的我都放在了另外一个模块里面，还有一个时钟分频器。指令存储器是用ip核实现的。  
	> ip核：指某一方提供的、形式为逻辑单元、芯片设计的可重用模块。  

	采用统一编址的方法，就是把传出来的指令地址进行分析，输入对应的控制信号，决定把数据传到哪里去。

 - 学到了什么东西
	
	简单的cpu的基本架构、数据之前的传输方式，以及具体工作方式。比如说输入一条指令，具体是怎么进行译码，怎么进行执行的等等。

 - 用到了哪些工具

	modelsim、MARS(the Mips Assembly and Runtime Simulator)Mips 汇编程序运行模拟器、Logisim（设计和模拟数字逻辑电路的辅助教学软件)、Xilinx ISE

	FPGA（Field－Programmable Gate Array），即现场可编程门阵列  

 - 简单理一下cpu工作的大致流程

	首先，初始化的时候pc值为0，将pc值传入指令存储器之后，输出32位的指令，根据不同指令进行不同处理。指令大致分为三种，寄存器型，立即数型和Jump型。  
	rs、rt表示源寄存器号，rd表示目的寄存器号。shamt存放短立即数，移位指令用到了。s - source，t - target，d - destination  
	简单说一下比如说执行add $1, $2这条指令，指令格式就是  

	||31..26||25..21||20..16||15..11||10..6||5..0||
	||op||rs||rt||rd||shamt||func||
	||000000||rs||rt||rd||0||100000||

	首先，把操作码传到指令译码器，再传到微操作序列产生部件产生相应的控制信号，把rs、rt、rd传到寄存器堆，寄存器堆把rs、rt值传到alu进行运算，运算结果写回到rd。然后pc寄存器加1。

###项目四（上创项目：智能手机平台上的统筹学习规划管理研究与实现）

 - 领域：移动应用开发

 - 为什么做这个？

	在目前市面上的移动应用，缺少一个方便快捷的综合性学习软件应用，大多数软件都只有比较单一的功能，使用起来不是很方便，所以我们致力于开发一个学习一体化的手机应用。

 - 解决什么问题：1）自我学习规划  2）实时便捷记录  3）在线讨论

 - 主要负责哪些模块？

	主要负责自我学习规划这一模块。

 - 实现了什么功能？

	分为三个小版块：1、旋转时间；2、今天时光； 3、时间轴。
	旋转时间：  
	选择类型：分为工作、学习、休息、娱乐四种类型，触摸屏幕旋转选择时间，写上标题，然后点击开始进行倒计时。  
	今天时光：  
	旋转时间里进行的都会以记录在这个板块,以饼状图的形式直观的显示出来，然后再今日时光里可以写日记。  
	时间轴：  
	在这里记录着之前每天你在各个类型上所花的时间，点击可以查看日记内容。

 - 介绍一下你的项目开发流程

	1. 首先了解关于android开发的基本知识  
	2. 然后思考都要完成什么功能
	3. 设计基本界面
	4. 寻找相应的解决方法及所需要的技术
		1. 记录计划需要数据库支持（sqlite）  
		Android 在运行时（run-time）集成了 SQLite，所以每个 Android 应用程序都可以使用 SQLite 数据库。直接使用API就可以了。  
		数据库很简答，只有一个表，包含了时间，周几，note，类型几个表项。  
		2. 旋转时间实现  
		获取手机分辨率，通过获取屏幕上面的触摸点，构造相应的函数来实现，具体实现方式不记得了，借鉴了网上的实现方法。  
	
	5. 编码实现  
		1. 基本界面的实现  
		2. 数据库  

 - 用到了哪些技术？

 - 用到了什么工具：

	 Java Development Kit（JDK）、Eclipse, Android SDK(软件开发工具包:Software Development Kit）、Android Development Tools (ADT)、 SQLite Manager（firefox上的一个扩展插件，用来管理sqlite）

###关于简历可能提的问题：
能力：熟悉基本的数据结构及算法，熟悉C++语言、Linux，了解verilog、c、html、git、python、java等，英语六级

基本数据结构：

抽象数据类型（Abstract Data Type)是指一个数学模型以及定义在该模型上的一组操作

- 数组（Array）：一个数组类型描述了连续分配的非空的具有特定元素对象类型的对象集合。  
- 堆栈（Stack）：是一个对象容器，插入对象和删除对象按照后进先出的原则。   
	使用：过程调用或递归 
- 队列（Queue）：也是一个对象容器，按照先进先出（FIFO, First-In-First-Out）的原则。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。  
	使用：多道程序设计，进程调度  
- 链表（Linked List）：是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。  
- 树（Tree）：是一种分层存储元素的抽象数据类型。  
	使用：比如文件系统就是树形结构的
- 图（Graph）：是表示物件与物件之间的关系的方法，是图论的基本研究对象。包括简单图/多重图;有向图/无向图等。  
	图的数据结构：1、邻接表；2、邻接矩阵；3、边表结构
	使用：很多，比如研究交通网络等等
- 堆（Heap）：实际上是二叉树的一种，将关键字集合存储在其内部结点中，叶子结点没有数据，符合一定的性质。比如最大堆的话满足内部结点结点值大于子结点值，且为完全树。  
	使用：主要用于实现优先队列
- 散列表（Hash）：（Hash table，也叫哈希表），是根据关键字（Key value）而直接访问在内存存储位置的数据结构。也就是说，它通过把键值通过一个函数的计算，映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。  
	冲突处理方法：1、线性探测法；2、再散列法 等等

基本算法：

- 枚举：列出某些有穷序列集的所有成员
- 搜索
	- 深度优先搜索：沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。
	- 广度优先搜索：从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。
	- 启发式搜索：  
	A星算法：在图形平面上，有多个节点的路径，求出最低通过成本的算法。  
	 g(n)表示从起点到任意顶点n的实际距离，h(n)表示任意顶点n到目标顶点的估算距离，那么 A星算法的公式为：f(n)=g(n)+h(n)。 这个公式遵循以下特性：  
	如果h(n)为0，只需求出g(n)，即求出起点到任意顶点n的最短路径，则转化为单源最短路径问题，即Dijkstra算法  
	如果h(n)<=“n到目标的实际距离”，则一定可以求出最优解。而且h(n)越小，需要计算的节点越多，算法效率越低。  
	比如八数码估值函数就是采用了每一步移到正确的位置需要的步数  
	- 遗传算法：

数据结构的算法

- 图论的算法
	- 哈夫曼编码：  
	霍夫曼树又称最优二叉树，在计算机数据处理中，霍夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。
	- 树的遍历：前序中序后序，深度广度
	- 最短路径算法：  
	确定起点的最短路径问题（适合用Dijkstra算法）：从V-S中选出Vj满足V0到Vj最短，将Vj加入S，修改V0至V-S任一顶点可达的最短路径长度，直到所有顶点都在V中。  
	全局最短路径问题（适合Floyd-Warshall 弗洛伊德算法）：逐步尝试在原路径中加入顶点k（k=0,1,2，...，n-1）作为中间顶点。  
	- 最小生成树算法：  
	普利姆算法（prim）：初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {}；  
	重复下列操作，直到Vnew = V：  
	1.在集合E中选取权值最小的边（u, v），其中u为集合Vnew中的元素，而v则是V中没有加入Vnew的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；
	2.将v加入集合Vnew中，将（u, v）加入集合Enew中；  
	克鲁斯卡尔算法（Kruskal）：每次选取权值最小的

- 分治法：把问题划分为一个或多个更小的子问题。递归地求解每个问题。

- 贪心算法：

- 动态规划：若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

- 加密算法：

	对称加密：将信息使用一个密钥进行加密，解密时使用同样的密钥，同样的算法进行解密。  
	数据加密标准（DES，Data Encryption Standard）
	高级加密标准（AES, Advanced Encryption Standard）

	非对称加密：又称公开密钥加密，是加密和解密使用不同密钥的算法，广泛用于信息传输中。  
	RSA加密算法

- 排序算法
	- 插入排序  
	直接插入排序：将L2~Ln一次插入到前面已排好序的子序列中（从后往前查找）  
	折半插入排序：通过折半查找来确定插入位置  
	希尔排序：先将排序表分割成若干个形如L[i, i+d, i+2d, ..., i+kd]（d越来越小）的特殊子表，分别进行插入排序，当整个表中元素已基本有序时，再对全体进行一次直接插入排序。  
	- 交换排序    
	冒泡排序O(n2):它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换。  
	快速排序O(n log n):在待排序表中任取一个元素作为基准，将其划分为独立的两部分后递归重复，直至每部分内只有一个元素或空。（以第一个元素为基准，首先从后往前扫描比基准小的元素，两者元素对换，再从前往后扫描比基准大的元素，与基准对换，以此类推）    
	- 选择排序  
	简答选择排序：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。  
	堆排序O(n log n):个近似完全二叉树的结构，满足子结点的键值或索引总是小于（或者大于）它的父节点。排序时一次对n/2~1各节点进行筛选。  
	- 归并排序O(n log n)  
	两路归并排序：n个记录看成n个子表，两两合并，再两两合并，直到合成一个长度为n的有序表。
	- 基数排序O(n):不是基于比较，而是采用多关键字思想，借助“分配”和“收集”两种操作对单逻辑关键字进行排序。

- 并行算法：并行算法就是用多台处理机 联合求解问题的方法和步骤,其执行过程是将给定的问题首先分解成若干个尽量相互独立的子问 题,然后使用多台计算机同时求解它,从而最终求得原问题的解.


- 什么是Linux？

	Linux是一种自由和开放源代码的类UNIX操作系统。

- 什么是python？

	python是一种面向对象、解释型的计算机程序设计语言。

- 什么是git？

	Git是一个分布式版本控制／软件配置管理软件，原是Linux内核开发者林纳斯·托瓦兹（Linus Torvalds）为更好地管理Linux内核开发而设计。

###和毕业设计有关的问题

- websocket和ajax比优点，为什么使用websocket？

	传统的请求-响应模式的 Web 开发在处理实时要求高、海量并发的应用通常采用实时通讯方案：

	- 轮询，原理简单易懂，就是客户端通过一定的时间间隔以频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。问题很明显，当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。

	- 基于 Flash，AdobeFlash 通过自己的 Socket 实现完成数据交换，再利用 Flash 暴露出相应的接口为 JavaScript 调用，从而达到实时传输目的。此方式比轮询要高效，且因为 Flash 安装率高，应用场景比较广泛，但在移动互联网终端上 Flash 的支持并不好。IOS 系统中没有 Flash 的存在，在 Android 中虽然有 Flash 的支持，但实际的使用效果差强人意，且对移动设备的硬件配置要求较高。2012 年 Adobe 官方宣布不再支持 Android4.1+系统，宣告了 Flash 在移动终端上的死亡。

	WebSocket 机制：  
	以下简要介绍一下 WebSocket 的原理及运行机制。  
	WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大不同是：  
	WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样；  
	WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信。


###非技术性问题

- 你为什么报考这个学校？

	首先，因为北京大学是世界上最好的学校之一，我想感受一下国际一流学校和国内一流学校有什么差别。  
    然后，我个人挺喜欢人文思想的，我觉得北京大学是我们国家自由思想人文思想最浓厚的学校。而且北京大学自从建校以来，就担任着社会发展改革的带头作用，北京大学是新文化运动的中心、五四运动的策源地。还有最近在热播的电视剧，《历史转折中的邓小平》中看到，也是北大的师生首先冒着生命危险否定了两个凡是。

- 你为什么报考这个专业？

	因为我本身对系统结构方面比较感兴趣，系统结构指的是计算机系统设计的观念与架构，描述计算机在实做的设计原则。之前我看过一本小说，《黑客与画家》，里面讲到了黑客与画家，两个职业看起来虽然好像毫不相关，但是却又有着本质上的共性，他们都是艺术家，设计师，只不过设计的东西不一样。我觉得研究系统结构方面的人也和画家一样，他们也是一群杰出的艺术家，不过他们更加低调。

- 简单说一下你对报考这个方向的认识。

	早在60年代麦卡锡(John McCarthy)就提出了把计算能力作为一种象水和电一样的公用事业提供给用户。云计算的第一个里程碑是，1999年Salesforce.com提出的通过一个网站向企业提供企业级的应用的概念。  
    云计算是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机和其他设备。云计算有很多的形式，比如说软件即服务（saas，这种类型的云计算通过浏览器把程序传给成千上万的用户）平台即服务（Paas这种形式的云计算把开发环境作为一种服务来提供）基础设施即服务（Iaas，把IT基础设施作为一种服务通过网络提供，以服务的形式提供虚拟硬件资源，包括服务器、存储、网络等)。  
	一重门：安全  
　　 安全问题是云计算所面临的第一大问题，在这里，技术的挑战与机制和意识的挑战并存。首先，在技术方面，按照Google的理念，如果云计算得以实现的话，那么未来人们在本地硬盘上几乎不保存数据,所有的数据在云里,一旦发生由于技术方面的因素导致的服务中断,那么用户只能束手无策。  
　　 二重门：人才  
　　 云计算的提倡者基本来自企业，但业界官员和计算机科学家表示，人才的匮乏可能会限制云计算技术未来的增长。目前，即使是美国最久负盛名的大学也很难找到提供云计算所需要的所有技术培训。 云计算是分布式计算，但是目前许多应用软件并不是为分布式计算而写，导致其在云计算中也难以应用。  
　　 三重门：标准  
	云计算的产业化步伐很快，各大企业投入了很多力量发展云计算产品。但是推动云计算的发展必须要有开	放的公共标准，包括基础设施价格、网络和互联网应用等都需要基于开放标准，这样才能使得用户尽情享受云计算应用和服务。

	云计算的几个特性，包括资源共享，快速部署，容易管理。这些特性的实现一般都会使用虚拟化技术。但是云计算不一定使用虚拟化，其中Iaas使用最多。  
	虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些资源。

- 说说你对科学研究的看法？

	从字面上的意思来理解呢，科学研究分为两个阶段，初级阶段主要是了解别人的成果,然后分析他们的优点和不足,做出改进,或者得出更加简洁的方法,这个阶段要多多阅读和涉猎。比较高级的阶段呢，就是发掘新的思路寻找新的方向,尝试一些从来没有人做过的一些东西，这个阶段要有很好的基础,有一定的科研经验，而且一次次的失败也是在所难免的。

- 举例说明科学研究都都哪些领域或方向？

	计算机系统结构方向的话比如说  
	分布式计算，主要研究分散系统（Distributed system）如何进行计算。分散系统就是一组电子计算机（computer），通过计算机网络相互链接传递消息与通信后并协调它们的行为而形成的系统。  
    高效能计算（主要解决大规模科学问题的计算和海量数据的处理，如科学研究、气象预报、计算模拟、军事研究、CFD/CAE、生物制药、基因测序、图像处理等等）等等。  

- 大一大二成绩不够突出，分析过原因吗？

	大一的时候因为刚买电脑，自制力比较差，花了大量的时间在游戏上面，所以成绩一下子就变差了。然后我们学校是大二的时候军训，军训结束之后就开始不玩游戏了。大二的时候把挺多时间花在学习之外的一些事情上，比如说做兼职，考驾照，旅游等等，除了晚上基本上都不呆在宿舍，所以花在学习上面的时间也不是很多。大二暑假的时候参加了支教活动，去贵州遵义的一个小镇支教了两个礼拜，那次支教对我来说影响挺大的。回来之后大三学年，我就把大部分时间都花在了学习上面了。

- 你喜欢你的专业吗？

	喜欢，首先，我觉得计算机这一个专业以已经是我们这个社会各个领域不可或缺的一个专业了，在计算机相关岗位上，我能够发挥比较大的社会价值。  
    然后，我觉得计算机的一些算法思想，对我看待事情的思维方式，帮助挺大的，遇到一些事情，我就比较喜欢用算法思想稍微分析一下。之前看过一篇文章，讲的程序算法与人生选择。  

	- 排序算法  
	比如说面临一些选择的时候，可以参考下排序算法，首先参考冒泡排序，把所有的选择都列出来，如果只选出一个最重要的，你会选哪一个？当一个一个过滤的时候，我就知道应该选择什么了。这个算法告诉我们，人的杂念越少，就越容易做出选择。  
	当茫然到不知道怎么比较两个决策因子大小的时候怎么办呢，可以参考下快速排序，一开始我们不需要找到最大的数，只要有一个标准，所以先把价值观中的某个标准拿出来，满足的放在右边，不满足的放在左边，在调整这个标准继续递归下去。这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择。  
	排序算法的核心思想就是，让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择。
  
	- 贪婪算法  
    是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。  
	对于人类，一般人在行为处事的时候都会采用贪婪算法，比如说找零钱，找36，我们会按照这样的顺序找，20,10,5,1。  
	过十字路口对角线  
	对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。
  
	- 动态规划  
	但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定，因而没法达到最佳解。  
	动态规划至少告诉了我们两点  
	1）承前启后非常重要，当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。  
	2）是否可以回退也很重要。这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你选了A公司，并不是你完全放弃了B公司。而是，你知道从A公司退出来去B公司，会比从B公司退出来去A公司要容易一些。  

	- Dijkstra最短路径  
	经典算法，是一个贪婪+动态规划的算法  
	1）在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。  
	2）从离自己最近的结点开始贪婪。  
	3）走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。  
	4）再贪婪与原点最短的结点，如此反复。  
	比如说我想成为一个架构师，但是这对于我来说，目前的距离是无穷大，把它们放在心里就可以了，先看看能够够着的东西。而我现在要做的就是把我看得见的在身边的东西干好。    

	> 系统架构师（System Architect，简称SA或SAr），是在信息系统研发中，负责依据需求来确定主要的技术选择、设计系统的主体框架结构，并负责搭建实施的人。 他们（与系统分析师共同）确立系统的主体架构和实现方向，并负责指导软件工程师等开发人员的编码开发工作。
  
	- 算法就是Trade-Off  
	任何的选择都意味着放弃——当你要去获得一个东西的时候，你总是需要放弃一些东西。就像我们编程用到的以时间换空间，以空间换时间的想法。  
	每个人都有每个人的算法，每个算法都有每个算法的purpose，就算每个人都在用同样的算法，结果也会不一样。  
	我们每个人的算法决定了我们的选择，我们的选择决定了我们的人生。

- 你有什么特长？

	跑步，这应该也算是我的爱好吧，我比较擅长长跑，大学1000米测试可以拿满分。

- 你是否愿意接受调剂？

	不愿意。

中英自我介绍：  
老师早上好/下午好。我叫章扬斌，上海同济大学计算机科学与技术专业的学生。很高兴能够参加这次面试。   
在大学期间，我学过编译原理，计算机系统机构，数据库，计算机网络等课程并且取得了优异的成绩。我也参加过一些和web开发，计算机组成相关的项目。我对计算机体系结构方面比较感兴趣，所以我觉得有必要进一步的学习研究相关知识。  
在空余时间，我喜欢跑步，坚持每两天跑一次步。这不仅使我保持良好的身体状态而且增强了我的耐力。我觉得科研工作也需要这些东西。在13年的时候我参加了上海国际马拉松半程的比赛并顺利的完成了比赛。除此之外，我还喜欢阅读。阅读经常能让我陷入反思，有时候也会改变我的一些想法甚至是对待人生的看法。《平凡的世界》 《三体》  
总的来说，我是一个勤奋的学生。我喜欢尝试一些自己没做过的事情。（比如说我骑自行车去厦门，比如说uart实验是进球动画，比如说在图书馆室内偷偷种花，比如说去支教的时候早上早早先坐客车，再坐摩的跑去一个还在开发的景点，比如说晚上八点多跑去河里游泳，比说说尝试收集99个国家的生日祝福，不过至今只完成了37个）科学研究也需要不断的尝试，所以我相信我能把它做好！我做喜欢的一句话是登山家马洛里回答《纽约时报》“你为什么要攀登珠穆朗玛峰”时的回答，“因为山就在那里”   
这就是我的自我介绍，谢谢老师！  
Good morning/afternoon, dear professors. I am Zhang Yangbin, a student from Tongji University and my major is computer science. I am glad to be here for the interview.  
I learned some lessons such as database, the Principle of Compiling, computer architecture and earned good grades. And I have taken part in some project relate to web development and computer organization in collage. I am interested in computer architecture, So I think further study is still urgent for me to realize self-value.  
In my spare time, I like running. I persisted in running every two days. It not only keeps me fit but also build my endurance. I think it also be helpful to scientific research. I took part in The Shanghai International Marathon in 2013 and finished the half Marathon. In addition, I like reading. It usually make me rethink. Sometimes, It even change my attitude to life.  
Generally speaking, I am a hard-working student. And I like to try new things. Scientific research also need keep trying. So I believe I can do it well. My favorite quote is Mollory's reply to the question "Why you want to climb Everest?" "Because it's there."   
Ok, that's all. thanks for your attention. 


[1]: http://nikefd.elastos.org/2015/01/19/9/    "u-boot编译"
[2]: http://nikefd.elastos.org/2015/01/26/%E5%9C%A8u-boot%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%9C%A8pandaboard%E4%B8%8A%E8%B7%91%E7%AE%80%E5%8D%95%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88experiment-2%EF%BC%89/  "u-boot上跑自己的小程序"
[data-path]: /image/interview-p/data-path.png
